<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Algorithmes de Cryptographie</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }
    h1 { text-align: center; }
    textarea, select, input, button {
      width: 100%; padding: 10px; margin: 10px 0;
    }
    button { cursor: pointer; background-color: #007BFF; color: white; border: none; }
    button:hover { background-color: #0056b3; }
  </style>
</head>
<body>
  <h1>Algorithmes de Cryptographie</h1>
  <label>Choisir un algorithme :</label>
  <select id="algorithm">
    <option value="albam">Albam</option>
    <option value="atbah">Atbah</option>
    <option value="atbash">Atbash</option>
    <option value="alberti">Alberti</option>
    <option value="polybe">Polybe</option>
    <option value="substitution">SubstitutionSimple</option>
    <option value="cesar">Cesar</option>
    <option value="vigenere">Vigenere</option>
    <option value="trithemius">Trithemius</option>
    <option value="autokey">Autokey</option>
    <option value="porta">Porta</option>
    <option value="beaufort">Beaufort</option>
    <option value="vernam">Vernam (OTP)</option>
  </select>
  <label>Clé (si nécessaire) :</label>
  <input type="text" id="key" placeholder="Entrez la clé si nécessaire">
  <label>Texte d'entrée :</label>
  <textarea id="input"></textarea>
  <button onclick="processText(true)">Chiffrer</button>
  <button onclick="processText(false)">Déchiffrer</button>
  <label>Texte de sortie :</label>
  <textarea id="output" readonly></textarea>
  <button onclick="downloadOutput()">Télécharger le résultat</button>

  <script>
    const ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    // Atbash (réversible, chiffrement = déchiffrement)
    function atbash(text) {
      return text.toUpperCase().replace(/[A-Z]/g, c =>
        String.fromCharCode(90 - (c.charCodeAt(0) - 65)));
    }

    // Albam (décalage de 13 positions, chiffrement = déchiffrement)
    function albam(text) {
      return text.toUpperCase().replace(/[A-Z]/g, c =>
        String.fromCharCode(((c.charCodeAt(0) - 65 + 13) % 26) + 65));
    }

    // Atbah (inversion de l'alphabet, chiffrement = déchiffrement)
    function atbah(text) {
      const reversed = ALPHA.split('').reverse().join('');
      return text.toUpperCase().replace(/[A-Z]/g, c => reversed[ALPHA.indexOf(c)]);
    }

    // Cesar (décalage avec clé, chiffrement/déchiffrement explicite)
    function cesar(text, key, decrypt = false) {
      if (!key || isNaN(key)) key = 0;
      let shift = parseInt(key) % 26;
      if (decrypt) shift = (26 - shift) % 26;
      return text.toUpperCase().replace(/[A-Z]/g, c =>
        String.fromCharCode(((c.charCodeAt(0) - 65 + shift) % 26) + 65));
    }

    // Vigenere (clé répétée, chiffrement/déchiffrement explicite)
    function vigenere(text, key, decrypt = false) {
      if (!key) key = 'A';
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      let result = '', j = 0;
      for (let i = 0; i < text.length; i++) {
        const c = text[i].toUpperCase();
        if (ALPHA.includes(c)) {
          let k = key[j % key.length].charCodeAt(0) - 65;
          if (decrypt) k = (26 - k) % 26;
          result += String.fromCharCode(((c.charCodeAt(0) - 65 + k) % 26) + 65);
          j++;
        } else {
          result += text[i];
        }
      }
      return result;
    }

    // Polybe (carré de Polybe, chiffrement/déchiffrement)
    function polybe(text, decrypt = false) {
      const square = {
        A: '11', B: '12', C: '13', D: '14', E: '15',
        F: '21', G: '22', H: '23', I: '24', J: '24', K: '25',
        L: '31', M: '32', N: '33', O: '34', P: '35',
        Q: '41', R: '42', S: '43', T: '44', U: '45',
        V: '51', W: '52', X: '53', Y: '54', Z: '55'
    };
      const reverse = Object.entries(square).reduce((r, [k, v]) => {
        if (!r[v]) r[v] = k; // I/J share the same code
        return r;
      }, {});
      if (!decrypt) {
        return text.toUpperCase().replace(/[A-Z]/g, c => square[c] || c);
      } else {
        let result = '';
        for (let i = 0; i < text.length; i += 2) {
          const pair = text.slice(i, i + 2);
          result += reverse[pair] || pair;
        }
        return result;
      }
    }

    // Substitution (alphabet mélangé, chiffrement/déchiffrement)
    function substitution(text, decrypt = false) {
      const shuffled = 'QWERTYUIOPASDFGHJKLZXCVBNM';
      const reverse = Object.fromEntries(ALPHA.split('').map((c, i) => [shuffled[i], c]));
      if (decrypt) {
        return text.toUpperCase().replace(/[A-Z]/g, c => reverse[c] || c);
      }
      return text.toUpperCase().replace(/[A-Z]/g, c => shuffled[ALPHA.indexOf(c)] || c);
    }

    // Trithemius (décalage progressif, chiffrement/déchiffrement)
    function trithemius(text, decrypt = false) {
      let j = 0;
      return text.toUpperCase().replace(/[A-Z]/g, (c) => {
        const offset = decrypt ? (26 - j) % 26 : j;
        j++;
        return String.fromCharCode(((c.charCodeAt(0) - 65 + offset) % 26) + 65);
      });
    }

    // Autokey (clé + texte comme clé, chiffrement/déchiffrement)
    function autokey(text, key, decrypt = false) {
      if (!key) key = 'A';
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      let extendedKey = key + (decrypt ? text.toUpperCase() : text.toUpperCase());
      let result = '', j = 0;
      for (let i = 0; i < text.length; i++) {
        const c = text[i].toUpperCase();
        if (ALPHA.includes(c)) {
          let k = extendedKey[j].charCodeAt(0) - 65;
          if (decrypt) k = (26 - k) % 26;
          result += String.fromCharCode(((c.charCodeAt(0) - 65 + k) % 26) + 65);
          j++;
        } else {
          result += text[i];
        }
      }
      return result;
    }

    // Porta (tableau de substitution, chiffrement = déchiffrement)
    function porta(text, key) {
      const pairs = [
        "NOPQRSTUVWXYZABCDEFGHIJKLM", "OPQRSTUVWXYZNMABCDEFGHIJKL",
        "PQRSTUVWXYZNOABCDEFGHIJKLM", "QRSTUVWXYZOPNABCDEFGHIJKLM",
        "RSTUVWXYZOPQNABCDEFGHIJKLM", "STUVWXYZOPQRNABCDEFGHIJKLM",
        "TUVWXYZOPQRSNABCDEFGHIJKLM", "UVWXYZOPQRSTNABCDEFGHIJKLM",
        "VWXYZOPQRSTUNABCDEFGHIJKLM", "WXYZOPQRSTUVNABCDEFGHIJKLM",
        "XYZOPQRSTUVWNABCDEFGHIJKLM", "YZOPQRSTUVWXNABCDEFGHIJKLM",
        "ZOPQRSTUVWXYNABCDEFGHIJKLM"
      ];
      if (!key) key = 'A';
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      let result = '', j = 0;
      for (let i = 0; i < text.length; i++) {
        const c = text[i].toUpperCase();
        if (ALPHA.includes(c)) {
          let k = (key[j % key.length].charCodeAt(0) - 65) % 26;
          let row = Math.floor(k / 2);
          result += pairs[row][ALPHA.indexOf(c)];
          j++;
        } else {
          result += text[i];
        }
      }
      return result;
    }

    // Beaufort (clé - texte, chiffrement = déchiffrement)
    function beaufort(text, key) {
      if (!key) key = 'A';
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      let result = '', j = 0;
      for (let i = 0; i < text.length; i++) {
        const c = text[i].toUpperCase();
        if (ALPHA.includes(c)) {
          let k = key[j % key.length].charCodeAt(0) - 65;
          result += String.fromCharCode(((k - (c.charCodeAt(0) - 65) + 26) % 26) + 65);
          j++;
        } else {
          result += text[i];
        }
      }
      return result;
    }

    // Vernam (OTP, chiffrement = déchiffrement)
    function vernam(text, key) {
      if (!key) key = 'A';
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      let result = '', j = 0;
      for (let i = 0; i < text.length; i++) {
        const t = text[i].toUpperCase();
        if (ALPHA.includes(t)) {
          const c = String.fromCharCode(((t.charCodeAt(0) - 65) ^ (key[j % key.length].charCodeAt(0) - 65)) + 65);
          result += c;
          j++;
        } else {
          result += text[i];
        }
      }
      return result;
    }

    // Alberti (simple implémentation avec deux alphabets)
    function alberti(text, key, decrypt = false) {
      if (!key) key = 'A';
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      const outer = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      const inner = 'ZEBRASCDFGHIJKLMNOPQTUVWXYZ';
      const reverseInner = Object.fromEntries(inner.split('').map((c, i) => [c, outer[i]]));
      let result = '', j = 0;
      for (let i = 0; i < text.length; i++) {
        const c = text[i].toUpperCase();
        if (ALPHA.includes(c)) {
          let k = key[j % key.length].charCodeAt(0) - 65;
          let shift = k % 26;
          let idx = (outer.indexOf(c) + (decrypt ? -shift : shift)) % 26;
          if (idx < 0) idx += 26;
          result += decrypt ? reverseInner[inner[idx]] : inner[idx];
          j++;
        } else {
          result += text[i];
        }
      }
      return result;
    }

    // Fonction principale pour traiter le texte
    function processText(encrypt = true) {
      const algo = document.getElementById('algorithm').value;
      const input = document.getElementById('input').value;
      const key = document.getElementById('key').value;
      let output = '';

      switch (algo) {
        case 'atbash': output = atbash(input); break;
        case 'atbah': output = atbah(input); break;
        case 'albam': output = albam(input); break;
        case 'cesar': output = cesar(input, key, !encrypt); break;
        case 'vigenere': output = vigenere(input, key, !encrypt); break;
        case 'polybe': output = polybe(input, !encrypt); break;
        case 'substitution': output = substitution(input, !encrypt); break;
        case 'trithemius': output = trithemius(input, !encrypt); break;
        case 'autokey': output = autokey(input, key, !encrypt); break;
        case 'porta': output = porta(input, key); break;
        case 'beaufort': output = beaufort(input, key); break;
        case 'vernam': output = vernam(input, key); break;
        case 'alberti': output = alberti(input, key, !encrypt); break;
        default: output = 'Algorithme non implémenté';
      }

      document.getElementById('output').value = output;
    }

    // Fonction pour télécharger le résultat
    function downloadOutput() {
      const outputText = document.getElementById('output').value;
      if (!outputText) {
        alert('Aucun résultat à télécharger !');
        return;
      }

      const blob = new Blob([outputText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);

      const link = document.createElement('a');
      link.href = url;
      link.download = 'resultat_cryptographie.txt';
      document.body.appendChild(link);
      link.click();

      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>